Testcontainers â€” Integration Testing Using Docker In .NET | by Milan JovanoviÄ‡ | Sep, 2023 | MediumTestcontainers â€” Integration Testing Using Docker In .NETMilan JovanoviÄ‡Â·Follow5 min readÂ·Sep 2--1ListenShareModern software applications rarely work in isolation. On the contrary, a typical application will talk to several external systems like databases, messaging systems, cache providers, and many 3rd party services. And itâ€™s up to you to ensure everything functions correctly.Hopefully, I donâ€™t have to convince you about the value of writing tests.You should be writing tests. Period.However, I do want to discuss the value of integration testing.Unit tests are helpful to test business logic in isolation, without any external services. They are easy to write and provide almost instant feedback.But you canâ€™t be fully confident in your application without integration tests.So, in this weekâ€™s newsletter, Iâ€™ll show you how to use Docker for integration testing.Hereâ€™s what we will use to write integration tests:TestcontainersDockerxUnitLetâ€™s dive in!What is Testcontainers?Testcontainers is a library for writing tests with throwaway Docker containers.Why should you use it?Integration testing is considered â€œdifficultâ€ because you have to maintain testing infrastructure. Before running tests, you need to make sure the database is up and running. You also have to seed any data required for the tests. If you have tests running in parallel on the same database, they could interfere with each other.A possible solution could be using in-memory variations of the required services. But this isnâ€™t much different from using mocks. In-memory services might not have all the features of the production service.Testcontainers solves this by using Docker to spin up real services for integration testing.Hereâ€™s an example of creating a SQL Server container:MsSqlContainer dbContainer = new MsSqlBuilder()    .WithImage("mcr.microsoft.com/mssql/server:2022-latest")    .WithPassword("Strong_password_123!")    .Build();You can then use the MsSqlContainer instance to get a connection string for the database running inside the container.Do you see how this is valuable for writing integration tests?No more need for mocks or fake in-memory databases. Instead, you can use the real deal.I wonâ€™t do a deep dive into this library here, so refer to the documentation for more information.Implementing a Custom WebApplicationFactoryASP.NET Core provides an in-memory test server that we can use to spin up an application instance for running tests. The Microsoft.AspNetCore.Mvc.Testing package provides the WebApplicationFactory class that we will use as the base for our implementation.WebApplicationFactory<TEntryPoint> is used to create a TestServer for the integration tests.The custom IntegrationTestWebAppFactory will do a few things:Create and configure a MsSqlContainer instanceCall ConfigureTestServices to set up EF Core with the container databaseStart and stop the container instance with IAsyncLifetimeMsSqlContainer has a GetConnectionString method to grab the connection string for the current container. Note that this can change between tests, as each test class will create a separate container instance. Test cases inside the same test class will use the same container instance. So keep that in mind if you need to do a cleanup between tests.Another thing to keep in mind is database migrations. You will have to run them manually before every test to create the required database structure.Starting the container instance is done asynchronously using IAsyncLifetime. The container is started inside StartAsync before any of the tests run. And it's stopped inside StopAsync.Hereâ€™s the complete code for IntegrationTestWebAppFactory:public class IntegrationTestWebAppFactory    : WebApplicationFactory<Program>,      IAsyncLifetime{    private readonly MsSqlContainer _dbContainer = new MsSqlBuilder()        .WithImage("mcr.microsoft.com/mssql/server:2022-latest")        .WithPassword("Strong_password_123!")        .Build();    protected override void ConfigureWebHost(IWebHostBuilder builder)    {        builder.ConfigureTestServices(services =>        {            var descriptorType =                typeof(DbContextOptions<ApplicationDbContext>);            var descriptor = services                .SingleOrDefault(s => s.ServiceType == descriptorType);            if (descriptor is not null)            {                services.Remove(descriptor);            }            services.AddDbContext<ApplicationDbContext>(options =>                options.UseSqlServer(_dbContainer.GetConnectionString()));        });    }    public Task InitializeAsync()    {        return _dbContainer.StartAsync();    }    public new Task DisposeAsync()    {        return _dbContainer.StopAsync();    }}Creating The Base Test ClassThe base test class will implement a class fixture interface IClassFixture. It indicates the class contains tests and provides shared object instances across the test cases inside. This is a good place to instantiate any services that are required for most tests.For example, Iâ€™m creating an IServiceScope for resolving scoped services inside the tests.ISender for sending commands and queriesApplicationDbContext for database setup or verifying resultspublic abstract class BaseIntegrationTest    : IClassFixture<IntegrationTestWebAppFactory>,      IDisposable{    private readonly IServiceScope _scope;    protected readonly ISender Sender;    protected readonly ApplicationDbContext DbContext;    protected BaseIntegrationTest(IntegrationTestWebAppFactory factory)    {        _scope = factory.Services.CreateScope();        Sender = _scope.ServiceProvider.GetRequiredService<ISender>();        DbContext = _scope.ServiceProvider            .GetRequiredService<ApplicationDbContext>();    }    public void Dispose()    {        _scope?.Dispose();        DbContext?.Dispose();    }}With all the infrastructure in place, weâ€™re finally ready to write the tests.Putting It All Together â€” Writing Integration TestsHereâ€™s a ProductTests class with an integration test inside.I use the Arrange-Act-Assert pattern to structure tests:Arrange â€” create the CreateProduct.Command instanceAct â€” send the command using ISender and store the resultAssert â€” use the result from the Act step to verify the database stateThe value of writing integration tests like this is that you can use the complete MediatR request pipeline. If you have any IPipelineBehavior wrapping the request, it will also be executed.The same applies if you write your business logic inside service classes. Instead of resolving the ISender, you would resolve the specific services you want to test.Most importantly, this test uses a real database instance running inside a Docker container.public class ProductTests : BaseIntegrationTest{    public ProductTests(IntegrationTestWebAppFactory factory)        : base(factory)    {    }    [Fact]    public async Task Create_ShouldCreateProduct()    {        // Arrange        var command = new CreateProduct.Command        {            Name = "AMD Ryzen 7 7700X",            Category = "CPU",            Price = 223.99m        };        // Act        var productId = await Sender.Send(command);        // Assert        var product = DbContext            .Products            .FirstOrDefault(p => p.Id == productId);        Assert.NotNull(product);    }}Running Integration Tests In CI/CD PipelinesYou can also run integration tests with Testcontainers inside CI/CD pipelines. The only requirement is that it supports Docker.GitHub Actions does support Docker. If you are hosting your project there, integration tests will work out of the box.You can learn more about building a CI/CD pipeline with GitHub Actions here.And if you want a plug-in solution, hereâ€™s a GitHub Actions workflow you can use:name: Run Tests ğŸš€on:  workflow_dispatch:  push:    branches:      - mainjobs:  run-tests:    runs-on: ubuntu-latest    steps:y      - uses: actions/checkout@v3      - name: Setup .NET        uses: actions/setup-dotnet@v3        with:          dotnet-version: '7.0.x'      - name: Restore        run: dotnet restore ./Products.Api.sln      - name: Build        run: dotnet build ./Products.Api.sln --no-restore      - name: Test        run: dotnet test ./Products.Api.sln --no-buildTakeawayTestcontainers is an excellent solution for writing integration tests with Docker. You can spin up and configure any Docker image and use it from your application. This is far better than using mocks or in-memory variations because they lack many features.If you have a CI/CD pipeline that supports Docker, Testcontainers will work out of the box.Only a few integration tests will drastically improve your confidence in the system.You can grab the source code for this newsletter on my GitHub. Itâ€™s completely free, so what are you waiting for?And if you prefer video, hereâ€™s a quick tutorial on integration testing with Testcontainers.Hope this was valuable.Stay awesome!Originally published at https://www.milanjovanovic.tech on September 2, 2023.P.S. Whenever youâ€™re ready, there are 2 ways I can help you:Pragmatic Clean Architecture: This comprehensive course will teach you the system I use to ship production-ready applications using Clean Architecture. Learn how to apply the best practices of modern software architecture. Join 870+ students here.Patreon Community: Think like a senior software engineer with access to the source code I use in my YouTube videos and exclusive discounts for my courses. Join 820+ engineers here.TestingIntegration TestingDockerDotnetAspnetcore----1FollowWritten by Milan JovanoviÄ‡604 FollowersI'm a seasoned software architect and Microsoft MVP for Developer Technologies. I talk about all things .NET and post new YouTube videos every week.FollowMore from Milan JovanoviÄ‡Milan JovanoviÄ‡Multi-Tenant Applications With EF CoreMost software applications today are built around the concept of multi-tenancy.4 min readÂ·May 20--3Milan JovanoviÄ‡MNW #041: The Right Way To Use HttpClient InÂ .NETIf youâ€™re building aÂ .NET application, chances are high that youâ€™ll need to call an external API over HTTP.5 min readÂ·Jun 10--3Milan JovanoviÄ‡CQRS Validation with MediatR Pipeline and FluentValidationValidation is an essential cross-cutting concern that you need to solve in your application. You want to ensure the request is valid beforeâ€¦5 min readÂ·Sep 30--Milan JovanoviÄ‡Health Checks In ASP.NET Core For Monitoring Your ApplicationsWe all want to build robust and reliable applications that can scale indefinitely and handle any number of requests.4 min readÂ·Apr 29--See all from Milan JovanoviÄ‡Recommended from MediumAlex Villegas.NET/C# Fundamentals for Senior DevsNulls, absence of value or referenceâ€¦7 min readÂ·Sep 21--9Vahid AlizadehinDevOps.devEvent sourcing implementation inÂ .NET microservicesThis article will cover Event-Sourcing architecture inÂ .NET 7 and almost everything required for developing services, such as a databaseâ€¦14 min readÂ·Sep 10--1ListsGeneral Coding Knowledge20 storiesÂ·471 savesCoding & Development11 storiesÂ·229 savesBusiness37 storiesÂ·35 savesNew_Reading_List174 storiesÂ·156 savesMuhammedAKBASinStackademic10 Complex C# Code Snippets for Various ScenariosAs a developer working with C#, you often encounter complex scenarios that require intricate code solutions. In this article, weâ€™ll exploreâ€¦5 min readÂ·Aug 20--4Joseph YamiTop 9 software architecture toolsThe best free and paid tools to visualize your software architecture6 min readÂ·Apr 28--Rico MarianiPerformance Improvements inÂ .NET 8This is a summary of the excellent and lengthy document by Stephen Toub14 min readÂ·Sep 25--Milan JovanoviÄ‡8 Tips To Write Clean CodeClean code is code thatâ€™s easy to read, maintain, and understand.7 min readÂ·Jul 15--See more recommendationsHelpStatusAboutCareersBlogPrivacyTermsText to speechTeams































